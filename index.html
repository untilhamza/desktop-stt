<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello World!</title>
  </head>

  <body>
    <h1>Hello World!!** test</h1>
    We are using node
    <div>
      <button id="start">Start</button>
      <button id="stop">Stop</button>
    </div>
    <!-- put red border and make video element seen -->
    <div style="border: 1px solid red; width: 1280px; height: 720px">
      <video
        id="video"
        autoplay
        playsinline
        muted
        style="width: 1280px; height: 720px"
      ></video>
    </div>

    <!-- canvas -->
    <div style="border: 1px solid red; width: 640px; height: 720px">
      <canvas id="canvas" width="640" height="720"></canvas>
    </div>

    <!-- cropped video -->
    <div style="border: 1px solid red; width: 480px; height: 500px">
      <video
        id="cropped-video"
        autoplay
        playsinline
        muted
        style="width: 480px; height: 500px"
      ></video>

    <audio />
    <script>
      document.write(process.versions.node);
    </script>
    , Chrome
    <script>
      document.write(process.versions.chrome);
    </script>
    , and Electron
    <script>
      document.write(process.versions.electron);
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

   <script src="https://cdn.jsdelivr.net/npm/axios@1.1.2/dist/axios.min.js"></script>
    <!-- <script src="/socket.io/socket.io.js"></script> -->
    <script type="module">
      // import { io } from "https://cdn.socket.io/4.4.1/socket.io.esm.min.js";
      // const SOCKET_ADDRESS = "http://localhost:3005";
      // const socket = io.connect(SOCKET_ADDRESS);
      // socket.on("connect", () => {
      //   console.log("connected to server");
      // });

      // socket.on("disconnect", () => {
      //   console.log("disconnected from server");
      // });

      // socket.on("message", (data) => {
      //   console.log(data);
      // });

      // socket.on("error", (error) => {
      //   console.log(error);
      //});
    </script>
    <script type="module">
      //In the preload script.
   //  import axios from 'axios';
    //  const axios = require('axios'); // legacy way
      console.log(axios);
      const { ipcRenderer } = require("electron");
      console.log(ipcRenderer);
      const stopButton = document.getElementById("stop");
      const startButton = document.getElementById("start");

      startButton.addEventListener("click", () => {
        //ipcRenderer.send("START"); //get source ID
      });

      stopButton.addEventListener("click", () => {
       // ipcRenderer.send("STOP");
       // stop video stream
      });

      ipcRenderer.on("SET_SOURCE", async (event, sourceId) => {
        console.log("** sourceId: " + sourceId);

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: sourceId,
                echoCancellation: true,
                googAutoGainControl: true,
                googNoiseSuppression: true,
                googHighpassFilter: true,
                googAudioMirroring: true,
              },
              optional: [],
            },

            video: {
              mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: sourceId,
                // minWidth: 1280,
                // maxWidth: 1280,
                // minHeight: 720,
                // maxHeight: 720,
              },
            },
          });
          handleStream(stream);
        } catch (e) {
          handleError(e);
        }
      });

      function handleStream(stream) {
         //const serverIpAddress = 'localhost';// "10.20.171.95";
        const video =  document.querySelector("video"); //
        const canvas = document.querySelector("#canvas");

       let requestAnimationFrameId = null;

        video.srcObject = stream;

        video.onloadedmetadata = (e) => {
         video.play()
         //TODO: set based on captureRect
         canvas.width= 800;  //video.videoWidth / 2; //500;
         canvas.height= 800; //video.videoHeight/2; //500;
    };

    video.onloadeddata = () => {
        //TODO: Crop stream
        const audioTrack = stream.getAudioTracks()[0];
        //const canvas = document.createElement("canvas");
      
        const ctx = canvas.getContext("2d");
        // canvas.width = video.videoWidth / 2; //1280;
        // canvas.height = video.videoHeight/2; //720;

        const draw = () => {
          console.log('drawing..')
         // ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          //  setTimeout(draw, 1000 / 30);
          //ctx.drawImage(video, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
          //sx - The x coordinate where to start clipping  ->   captureRect.x
          //sy - The y coordinate where to start clipping ->  captureRect.y
          //sWidth - The width of the clipped image (how much it clips on width) -> captureRect.width
          //sHeight - The height of the clipped image (how much it clips on height) -> captureRect.height

          //dx - The x coordinate where to place the image on the canvas
          //dy - The y coordinate where to place the image on the canvas

          //dWidth - [optional]The width of the image to use (stretch or reduce the image)
          //dHeight -[optional] The height of the image to use (stretch or reduce the image)
          ctx.drawImage(video, 10,10,800,800,0,0,800,800);
         requestAnimationFrameId = requestAnimationFrame(draw);

        };

        //TODO: Draw cropped video frame on canvas
        draw();

        //TODO: Or crop video on server side
        

        //Add audio to cropped video stream
        const croppedStream = new MediaStream([audioTrack]);
        croppedStream.addTrack(canvas.captureStream().getVideoTracks()[0]);


        //Show cropped video -test
        // const croppedVideo = document.querySelector("#cropped-video");
        // croppedVideo.srcObject = croppedStream;
        // croppedVideo.width = 480;
        // croppedVideo.height = 500;
        // croppedVideo.onloadedmetadata = (e) => croppedVideo.play();


        //TODO: Record stream
      const mediaRecorder = new MediaRecorder(croppedStream);
        //const mediaRecorder = new MediaRecorder(stream);

        //TODO: record stream 
        mediaRecorder.start();

        let recordedBlobs = [];

        mediaRecorder.ondataavailable = (e) => {
          console.log("media data", e.data);
          recordedBlobs.push(e.data);
        };

        setTimeout(() => {
          mediaRecorder.stop();
          cancelAnimationFrame(requestAnimationFrameId);
          //TODO: stop the stream  from user media
        }, 60000);

        mediaRecorder.onstop = (e) => {
          //cancelAnimationFrame(requestAnimationFrameId);
          clearInterval(timeIntervalId);
          console.log("recording stopped");
          const blob = new Blob(recordedBlobs, { type: "video/webm" });

          //TODO: send to iframe for uploading to s3
          //window.parent.postMessage({ type: "upload to s3" blob }, "*");

          //TODO: Or send base64 to server for cropping
          // const reader = new FileReader();
          // reader.readAsDataURL(blob);
          // reader.onload = ()=>{
          //   const base64data = reader.result;
          //  // console.log("base64data", base64data);
          // }

          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.style.display = "none";
          a.href = url;
          a.download = "recorded-stream"+ new Date().toISOString() + ".webm";
          document.body.appendChild(a);
          a.click();
        };
      };

    }
      function handleError(e) {
        console.log(e);
      }

      function stopStreamedVideo(videoElem) {
        const stream = videoElem.srcObject;
        const tracks = stream.getTracks();

        tracks.forEach(function (track) {
          track.stop();
        });

        videoElem.srcObject = null;
      }

      // Async message handler
      ipcRenderer.on("asynchronous-reply", (event, arg) => {
        console.log("asynchronous-reply ", arg);
      });

      // Async message sender
      ipcRenderer.send("GET_SOURCE", "ping to main from primary html file");
    </script>
  </body>
</html>
